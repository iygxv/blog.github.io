import{_ as a,c as e,o as t,N as c}from"./chunks/framework.7288ae32.js";const f=JSON.parse('{"title":"8.14-总结本周数组API","description":"","frontmatter":{},"headers":[],"relativePath":"article/daily-study/2022/august/8.14-总结本周数组API.md"}'),o={name:"article/daily-study/2022/august/8.14-总结本周数组API.md"},d=c('<h1 id="_8-14-总结本周数组api" tabindex="-1">8.14-总结本周数组API <a class="header-anchor" href="#_8-14-总结本周数组api" aria-label="Permalink to &quot;8.14-总结本周数组API&quot;">​</a></h1><h2 id="reduce总结" tabindex="-1">reduce总结 <a class="header-anchor" href="#reduce总结" aria-label="Permalink to &quot;reduce总结&quot;">​</a></h2><ul><li>没有传入<code>callbackFn</code>会报错</li><li>传入<code>callbackFn</code>非函数也会报错</li><li>如果有<code>initialValue</code>, 则会被作为初始值, 没有则会取数组的第一位作为初始值(数组必须有长度)</li><li>数组循环的处理, 我们要做的就是将每次循环的<code>callbackFn</code>参数给到就行</li></ul><h2 id="flat总结" tabindex="-1">flat总结 <a class="header-anchor" href="#flat总结" aria-label="Permalink to &quot;flat总结&quot;">​</a></h2><p>实现<code>flat</code>方法主要是使用递归</p><p><code>Infinity</code>是比任何数字都大的, 所以<code>当depth为Infinity时 depth &gt; 0</code>永远成立</p><h2 id="map总结" tabindex="-1">map总结 <a class="header-anchor" href="#map总结" aria-label="Permalink to &quot;map总结&quot;">​</a></h2><p>实现<code>map</code>方法主要是将每次callback执行的结果给到新数组</p><h2 id="includes总结" tabindex="-1">includes总结 <a class="header-anchor" href="#includes总结" aria-label="Permalink to &quot;includes总结&quot;">​</a></h2><p>实现<code>includes</code>方法主要通过<code>Object.is</code>来判断相等的问题</p><h2 id="at总结" tabindex="-1">at总结 <a class="header-anchor" href="#at总结" aria-label="Permalink to &quot;at总结&quot;">​</a></h2><p><code>Math.trunc() </code>方法会将数字的小数部分去掉，只保留整数部分</p><p>实现<code>at</code>的方法也很容易, 主要是拿到对应元素的索引, 然后拿值</p>',13),l=[d];function i(r,n,s,h,_,u){return t(),e("div",null,l)}const m=a(o,[["render",i]]);export{f as __pageData,m as default};
