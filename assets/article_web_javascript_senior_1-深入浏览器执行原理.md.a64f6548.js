import{_ as a,c as r,o as t,N as o}from"./chunks/framework.7288ae32.js";const e="/blog_static/assets/image-20220717165750641.ae954c6f.png",i="/blog_static/assets/image-20220717170057141.61036e8a.png",s="/blog_static/assets/image-20220717172536119.d6b0f315.png",n="/blog_static/assets/image-20220717173311658.107901da.png",l="/blog_static/assets/image-20220717173629648.c8b56a96.png",J=JSON.parse('{"title":"深入浏览器执行原理","description":"","frontmatter":{},"headers":[],"relativePath":"article/web/javascript/senior/1-深入浏览器执行原理.md"}'),g={name:"article/web/javascript/senior/1-深入浏览器执行原理.md"},p=o('<h1 id="深入浏览器执行原理" tabindex="-1">深入浏览器执行原理 <a class="header-anchor" href="#深入浏览器执行原理" aria-label="Permalink to &quot;深入浏览器执行原理&quot;">​</a></h1><h2 id="javascript是一门编程语言" tabindex="-1"><strong>JavaScript是一门编程语言</strong> <a class="header-anchor" href="#javascript是一门编程语言" aria-label="Permalink to &quot;**JavaScript是一门编程语言**&quot;">​</a></h2><p>为什么这里我要强调JavaScript是一门编程语言呢?很多同学想，我还不知道JavaScript是一门编程语言吗?</p><p>事实上我们可以使用更加准备的描述是这样:<strong>JavaScript是一门高级的编程语言。</strong></p><p>那么有高级编程语言，就有低级编程语言，从编程语言发展历史来说，可以划分为三个阶段:</p><ul><li>机器语言:1000100111011000，一些机器指令</li><li>汇编语言:mov ax,bx，一些汇编指令</li><li>高级语言:C、C++、Java、JavaScript、Python</li></ul><p>但是计算机它本身是不认识这些高级语言的，所以我们的代码最终还是需要被转换成机器指令:</p><img src="'+e+'" alt="image-20220717165750641" style="zoom:50%;"><h2 id="浏览器的工作原理" tabindex="-1"><strong>浏览器的工作原理</strong> <a class="header-anchor" href="#浏览器的工作原理" aria-label="Permalink to &quot;**浏览器的工作原理**&quot;">​</a></h2><p>JavaScript代码，在浏览器中是如何被执行的?</p><img src="'+i+'" alt="image-20220717170057141"><p>输入网址后, 从服务器中拿去静态资源, 先拿<code>index.html</code>进行加载, 遇到<code>css文件</code>,然后再去拿css资源, 遇到<code>js文件</code>,再去js拿资源</p><h2 id="浏览器的内核" tabindex="-1"><strong>浏览器的内核</strong> <a class="header-anchor" href="#浏览器的内核" aria-label="Permalink to &quot;**浏览器的内核**&quot;">​</a></h2><p>不同的浏览器有不同的内核组成</p><ul><li><strong>Gecko</strong>:早期被Netscape和Mozilla Firefox浏览器浏览器使用;</li><li><strong>Triden</strong>:微软开发，被IE4~IE11浏览器使用，但是Edge浏览器已经转向Blink;</li><li><strong>Webkit</strong>:苹果基于KHTML开发、开源的，用于Safari，Google Chrome之前也在使用;</li><li><strong>Blink</strong>:是Webkit的一个分支，Google开发，目前应用于Google Chrome、Edge、Opera等;</li></ul><p>事实上，我们经常说的浏览器内核指的是浏览器的排版引擎</p><p><strong>排版引擎</strong>(layout engine)，也称为<strong>浏览器引擎</strong>(browser engine)、<strong>页面渲染引擎</strong>(rendering engine) 或<strong>样版引擎</strong>。</p><h2 id="浏览器渲染过程" tabindex="-1"><strong>浏览器渲染过程</strong> <a class="header-anchor" href="#浏览器渲染过程" aria-label="Permalink to &quot;**浏览器渲染过程**&quot;">​</a></h2><img src="'+s+'" alt="image-20220717172536119" style="zoom:67%;"><p>在这个执行过程中，HTML解析的时候遇到了JavaScript标签, <strong>会停止解析HTML，而去加载和执行JavaScript代码</strong></p><p>那么，JavaScript代码由谁来执行呢? <strong>JavaScript引擎</strong></p><h2 id="认识javascript引擎" tabindex="-1"><strong>认识JavaScript引擎</strong> <a class="header-anchor" href="#认识javascript引擎" aria-label="Permalink to &quot;**认识JavaScript引擎**&quot;">​</a></h2><p><strong>为什么需要JavaScript引擎呢?</strong></p><ul><li>我们前面说过，<strong>高级的编程语言</strong>都是需要<strong>转成最终的机器指令</strong>来执行的;</li><li>事实上我们编写的JavaScript无论你交给<strong>浏览器或者Node执行</strong>，最后都是需要被<strong>CPU执行</strong>的;</li><li>但是CPU只认识自己的指令集，实际上是机器语言，才能被CPU所执行;</li><li>所以我们需要<strong>JavaScript引擎帮助我们将JavaScript代码翻译成CPU指令</strong>来执行;</li></ul><p><strong>比较常见的JavaScript引擎有哪些呢?</strong></p><ul><li><p><strong>SpiderMonkey</strong>:第一款JavaScript引擎，由Brendan Eich开发(也就是JavaScript作者);</p></li><li><p><strong>Chakra</strong>:微软开发，用于IT浏览器;</p></li><li><p><strong>JavaScriptCore</strong>:WebKit中的JavaScript引擎，Apple公司开发;</p></li><li><p><strong>V8</strong>:Google开发的强大JavaScript引擎，也帮助Chrome从众多浏览器中脱颖而出;</p></li></ul><h2 id="浏览器内核和js引擎的关系" tabindex="-1"><strong>浏览器内核和JS引擎的关系</strong> <a class="header-anchor" href="#浏览器内核和js引擎的关系" aria-label="Permalink to &quot;**浏览器内核和JS引擎的关系**&quot;">​</a></h2><p>这里我们先以WebKit为例，WebKit事实上由两部分组成的:</p><ul><li><strong>WebCore</strong>:负责HTML解析、布局、渲染等等相关的工作;</li><li><strong>JavaScriptCore</strong>:解析、执行JavaScript代码;</li></ul><p>另外一个强大的JavaScript引擎就是<code>V8引擎</code></p><h2 id="v8引擎的原理" tabindex="-1"><strong>V8引擎的原理</strong> <a class="header-anchor" href="#v8引擎的原理" aria-label="Permalink to &quot;**V8引擎的原理**&quot;">​</a></h2><p>我们来看一下官方对V8引擎的定义:</p><ul><li>V8是用C ++编写的Google开源高性能JavaScript和WebAssembly引擎，它用于Chrome和Node.js等。</li><li>它实现<code>ECMAScript</code>和<code>WebAssembly</code>，并在Windows 7或更高版本，macOS 10.12+和使用x64，IA-32， ARM或MIPS处理器的Linux系统上运行。</li><li>V8可以独立运行，也可以嵌入到任何C ++应用程序中。</li></ul><p><img src="'+n+'" alt="image-20220717173311658"></p><h2 id="v8引擎的架构" tabindex="-1"><strong>V8引擎的架构</strong> <a class="header-anchor" href="#v8引擎的架构" aria-label="Permalink to &quot;**V8引擎的架构**&quot;">​</a></h2><p>V8引擎本身的源码<strong>非常复杂</strong>，大概有超过<strong>100w行C++代码</strong>，通过了解它的架构，我们可以知道它是如何对JavaScript执行的:</p><p><strong>Parse模块</strong>会将JavaScript代码转换成AST(抽象语法树)，这是因为解释器并不直接认识JavaScript代码;</p><ul><li>如果函数没有被调用，那么是不会被转换成AST的;</li><li>Parse的V8<a href="https://v8.dev/blog/scanner" target="_blank" rel="noreferrer">官方文档</a></li></ul><p><strong>Ignition</strong>是一个解释器，会将AST转换成ByteCode(字节码)</p><ul><li>同时会收集TurboFan优化所需要的信息(比如函数参数的类型信息，有了类型才能进行真实的运算);</li><li>如果函数只调用一次，Ignition会执行解释执行ByteCode;</li><li>Ignition的V8<a href="https://v8.dev/blog/ignition-interpreter" target="_blank" rel="noreferrer">官方文档</a></li></ul><p><strong>TurboFan</strong>是一个编译器，可以将字节码编译为CPU可以直接执行的机器码;</p><ul><li>如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能;</li><li>但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化(比如sum函数原来执行的是 number类型，后来执行变成了string类型)，之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码;</li><li>TurboFan的V8<a href="https://v8.dev/blog/turbofan-jit" target="_blank" rel="noreferrer">官方文档</a></li></ul><h2 id="v8引擎的解析图-官方" tabindex="-1"><strong>V8引擎的解析图(官方)</strong> <a class="header-anchor" href="#v8引擎的解析图-官方" aria-label="Permalink to &quot;**V8引擎的解析图(官方)**&quot;">​</a></h2><p><img src="'+l+'" alt="image-20220717173629648"></p><h2 id="v8执行的细节" tabindex="-1"><strong>V8执行的细节</strong> <a class="header-anchor" href="#v8执行的细节" aria-label="Permalink to &quot;**V8执行的细节**&quot;">​</a></h2><p><strong>我们的JavaScript源码是如何被解析(Parse过程)的呢?</strong></p><p>Blink将源码交给V8引擎，Stream获取到源码并且进行编码转换;</p><p>Scanner会进行词法分析(lexical analysis)，词法分析会将代码转换成tokens;</p><p><strong>接下来tokens会被转换成AST树，经过Parser和PreParser:</strong></p><ul><li>Parser就是直接将tokens转成AST树架构;</li><li>PreParser称之为预解析，为什么需要预解析呢?</li><li>这是因为并不是所有的JavaScript代码，在一开始时就会被执行。那么对所有的JavaScript代码进行解析，必然会 影响网页的运行效率;</li><li>所以V8引擎就实现了Lazy Parsing(延迟解析)的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂 时需要的内容，而对函数的全量解析是在函数被调用时才会进行;</li><li>比如我们在一个函数outer内部定义了另外一个函数inner，那么inner函数就会进行预解析;</li></ul><p>生成AST树后，会被Ignition转成字节码(bytecode)，之后的过程就是代码的执行过程(后续会详细分析)。</p>',51),c=[p];function d(h,u,v,b,_,m){return t(),r("div",null,c)}const P=a(g,[["render",d]]);export{J as __pageData,P as default};
