import{_ as e,c as t,o as r,a as l}from"./app.f58bd366.js";const i="/assets/image-20220904153324464.2cdc0a6d.png",P=JSON.parse('{"title":"9.4-总结本周(9月第一周)","description":"","frontmatter":{},"headers":[{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[{"level":3,"title":"目标","slug":"目标","link":"#目标","children":[]},{"level":3,"title":"本周学了什么","slug":"本周学了什么","link":"#本周学了什么","children":[]}]},{"level":2,"title":"http的一个发展历程","slug":"http的一个发展历程","link":"#http的一个发展历程","children":[{"level":3,"title":"各种版本的比较","slug":"各种版本的比较","link":"#各种版本的比较","children":[]}]},{"level":2,"title":"http是什么","slug":"http是什么","link":"#http是什么","children":[]},{"level":2,"title":"与HTTP相关的各种概念","slug":"与http相关的各种概念","link":"#与http相关的各种概念","children":[{"level":3,"title":"浏览器","slug":"浏览器","link":"#浏览器","children":[]},{"level":3,"title":"Web服务器","slug":"web服务器","link":"#web服务器","children":[]},{"level":3,"title":"CDN","slug":"cdn","link":"#cdn","children":[]},{"level":3,"title":"爬虫","slug":"爬虫","link":"#爬虫","children":[]},{"level":3,"title":"WAF","slug":"waf","link":"#waf","children":[]},{"level":3,"title":"TCP/IP","slug":"tcp-ip","link":"#tcp-ip","children":[]},{"level":3,"title":"DNS","slug":"dns","link":"#dns","children":[]},{"level":3,"title":"URI/URL","slug":"uri-url","link":"#uri-url","children":[]},{"level":3,"title":"HTTPS","slug":"https","link":"#https","children":[]},{"level":3,"title":"代理","slug":"代理","link":"#代理","children":[]}]}],"relativePath":"article/daily-study/2022/september/9.4-总结本周.md"}'),n={name:"article/daily-study/2022/september/9.4-总结本周.md"},o=l('<h1 id="_9-4-总结本周-9月第一周" tabindex="-1">9.4-总结本周(9月第一周) <a class="header-anchor" href="#_9-4-总结本周-9月第一周" aria-hidden="true">#</a></h1><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><h3 id="目标" tabindex="-1">目标 <a class="header-anchor" href="#目标" aria-hidden="true">#</a></h3><p>本月的目标的学习<code>http相关知识</code>,星期一到星期五去学习总结, 星期六休息, 星期天总结本周</p><h3 id="本周学了什么" tabindex="-1">本周学了什么 <a class="header-anchor" href="#本周学了什么" aria-hidden="true">#</a></h3><ul><li>http的一个发展历程</li><li>http是什么</li><li>与http相关的各种概念</li></ul><h2 id="http的一个发展历程" tabindex="-1">http的一个发展历程 <a class="header-anchor" href="#http的一个发展历程" aria-hidden="true">#</a></h2><ul><li>HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文</li><li>HTTP/0.9 是个简单的文本协议，只能获取文本资源(<strong>1989</strong>)</li><li>HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准(<strong>1996</strong>)</li><li>HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善(<strong>1999</strong>)</li><li>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及(<strong>2015</strong>)</li><li>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向(<strong>2018</strong>)</li></ul><h3 id="各种版本的比较" tabindex="-1">各种版本的比较 <a class="header-anchor" href="#各种版本的比较" aria-hidden="true">#</a></h3><p><strong>HTTP/1.0</strong> 相比较 <strong>HTTP/0.9</strong></p><ul><li>增加了 HEAD、POST 等新方法</li><li>增加了响应状态码，标记可能的错误原因</li><li>引入了协议版本号概念</li><li>引入了 HTTP Header(头部)的概念，让 HTTP 处理请求和响应更加灵活</li><li>传输的数据不再仅限于文本</li></ul><p><strong>HTTP/1.1</strong> 相比较 <strong>HTTP/1.0</strong></p><ul><li><p>它是一个正式的标准(<strong>HTTP/1.1</strong>)，而不是一份可有可无的参考文档(<strong>HTTP/1.0</strong>)。</p></li><li><p>增加了 PUT、DELETE 等新的方法</p></li><li><p>增加了缓存管理和控制(<code>增加了缓存管理,同一个请求不需要每次都需要经过三次握手</code>)</p></li><li><p>明确了连接管理，允许持久连接(<code>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，HTTP1.1默认支持长连接</code>)</p></li><li><p>允许响应数据分块(chunked)，利于传输大文件</p></li><li><p>强制要求 Host 头，让互联网主机托管成为可能(<code>HTTP1.0是没有host域的，HTTP1.1才支持这个参数</code>)</p></li></ul><p><strong>HTTP/2.0</strong> 相比较 <strong>HTTP/1.1</strong></p><p>2015年, `发布了 <strong>HTTP/2</strong>, <strong>HTTP/2</strong> 的制定充分考虑了现今互联网的现状:宽带、移动、不安全，在高度兼容</p><ul><li>二进制协议，不再是纯文本(<code>二进制协议</code>)</li><li>可发起多个请求，废弃了 1.1 里的管道(<code>多路复用</code>)</li><li>使用专用算法压缩头部，减少数据传输量(<code>头部压缩, 使得可以在header带更多数据了</code>)</li><li>允许服务器主动向客户端推送数据(<code>服务器主动push数据到客户端</code>)</li><li>增强了安全性，“事实上”要求加密通信(<code>安全性</code>)</li></ul><p><strong>HTTP/3.0</strong> 相比较 <strong>HTTP/2.0</strong></p><img src="'+i+'" alt="image-20220904153324464" style="zoom:50%;"><p><strong>HTTP/3.0</strong>是基于<a href="https://so.csdn.net/so/search?q=UDP&amp;spm=1001.2101.3001.7020" target="_blank" rel="noreferrer">UDP</a>协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议.</p><ul><li><p>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性</p></li><li><p>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</p></li><li><p>解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题（<code>解决TCP层的队头阻塞问题</code>)</p></li><li><p>可以快速进行三次握手(<code>快速握手</code>)</p></li></ul><h2 id="http是什么" tabindex="-1">http是什么 <a class="header-anchor" href="#http是什么" aria-hidden="true">#</a></h2><p><strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p><ul><li>计算机世界里</li><li>俩点(<code>必须是双方</code>)</li><li>传输文字、图片、音频、视频等超文本数据</li><li>是一种约定和规范</li></ul><h2 id="与http相关的各种概念" tabindex="-1">与HTTP相关的各种概念 <a class="header-anchor" href="#与http相关的各种概念" aria-hidden="true">#</a></h2><h3 id="浏览器" tabindex="-1"><strong>浏览器</strong> <a class="header-anchor" href="#浏览器" aria-hidden="true">#</a></h3><p>HTTP 协议中的<strong>请求方</strong></p><h3 id="web服务器" tabindex="-1"><strong>Web</strong>服务器 <a class="header-anchor" href="#web服务器" aria-hidden="true">#</a></h3><p>HTTP协议另一端的<strong>应答方</strong>(响应方)是<strong>服务器</strong>，<strong>Web Server</strong></p><h3 id="cdn" tabindex="-1"><strong>CDN</strong> <a class="header-anchor" href="#cdn" aria-hidden="true">#</a></h3><p><strong>CDN</strong>，全称是Content Delivery Network，就是<code>内容分发网络</code>。它应用 了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</p><p><strong>CDN的好处:</strong></p><ul><li>可以<code>缓存源站的数据</code>,让浏览器的请求不用千里迢迢地到达源站服务器， 直接在半路就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的 节点，大幅度缩短响应时间。</li><li>除了基本的网络加速外，还提供负载均衡、 安全防护、边缘计算、跨运营商网络等功能，能够成倍地放大源站服务器的服务能力</li></ul><h3 id="爬虫" tabindex="-1"><strong>爬虫</strong> <a class="header-anchor" href="#爬虫" aria-hidden="true">#</a></h3><p>HTTP 协议并没有规定用户代理后面必须是真正的人类，它也完全可以是机器人，这些机器人的正式名称就叫做<strong>爬虫</strong>(Crawler)，实际上是一种可以自动访 问 Web 资源的应用程序。</p><h3 id="waf" tabindex="-1"><strong>WAF</strong> <a class="header-anchor" href="#waf" aria-hidden="true">#</a></h3><p><strong>WAF</strong>是近几年比较火的一个词，意思是网络应用防火墙。与硬件防火墙类 似，它是应用层面的防火墙，专门检测 HTTP 流量，是防护 Web 应用的安全技术。</p><p>WAF 通常位于 Web 服务器之前，可以<code>阻止如 SQL 注入、跨站脚本等攻击</code>，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</p><h3 id="tcp-ip" tabindex="-1"><strong>TCP/IP</strong> <a class="header-anchor" href="#tcp-ip" aria-hidden="true">#</a></h3><p>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是<strong>TCP</strong>和<strong>IP</strong>，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p><ul><li>tcp 传输数据</li><li>ip 寻找地址</li></ul><h3 id="dns" tabindex="-1"><strong>DNS</strong> <a class="header-anchor" href="#dns" aria-hidden="true">#</a></h3><p>因为在TCP/IP 协议中使用 IP 地址来标识计算机,难以记忆与输入, 于是<strong>域名系统</strong>(<strong>Domain Name System</strong>)出现了</p><p><strong>域名解析:</strong> 用<code>域名映射真实IP</code>,因为如果要使用 TCP/IP 协议来通信仍然要使用IP地址</p><h3 id="uri-url" tabindex="-1"><strong>URI/URL</strong> <a class="header-anchor" href="#uri-url" aria-hidden="true">#</a></h3><p>有了TCP/IP 和 DNS, 我们还不能任意访问网络上的资源</p><p>DNS 和 IP 地址只是标记了互联网上的主机，但主机上有那么多文本、图片、页面到底要找哪一个呢?</p><p>于是就出现了 URI(<strong>Uniform Resource Identifier</strong>)，中文名称是 <strong>统一资源标识符</strong>，使用它就能够唯一地标记互联网上资源</p><h3 id="https" tabindex="-1"><strong>HTTPS</strong> <a class="header-anchor" href="#https" aria-hidden="true">#</a></h3><p>HTTPS是<code>运行在SSL/TLS 协议上的 HTTP</code>(<strong>HTTP over SSL/TLS</strong>)</p><p>SSL 使用了许多密码学最先进的研究成果，综合了<code>对称加密</code>、<code>非对称加密</code>、<code>摘要算法</code>、<code>数字签名</code>、<code>数字证书</code>等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲</p><h3 id="代理" tabindex="-1"><strong>代理</strong> <a class="header-anchor" href="#代理" aria-hidden="true">#</a></h3><p>代理(Proxy)是 HTTP 协议中请求方和应答方中间的一个环节，作为中转站，既可以 转发客户端的请求，也可以转发服务器的应答。</p><p><strong>代理有很多的种类，常见的有:</strong></p><ul><li>匿名代理:完全隐匿了被代理的机器，外界看到的只是代理服务器</li><li>透明代理:顾名思义，它在传输过程中是透明开放的，外界既知道代理，也知道客户端</li><li>正向代理:靠近客户端，代表客户端向服务器发送请求(<code>作为客户端</code>)</li><li>反向代理:靠近服务器端，代表服务器响应客户端的请求(<code>作为服务器</code>)</li></ul>',54),s=[o];function a(d,h,c,p,g,T){return r(),t("div",null,s)}const H=e(n,[["render",a]]);export{P as __pageData,H as default};
