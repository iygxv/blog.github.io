import{_ as e}from"./chunks/image-20220912225450540.f09cc845.js";import{_ as o,c as i,o as l,a as t}from"./app.f58bd366.js";const k=JSON.parse('{"title":"9.28-复习一","description":"","frontmatter":{},"headers":[{"level":2,"title":"复习的知识","slug":"复习的知识","link":"#复习的知识","children":[{"level":3,"title":"HTTP的发展历程","slug":"http的发展历程","link":"#http的发展历程","children":[]},{"level":3,"title":"域名的形式","slug":"域名的形式","link":"#域名的形式","children":[]},{"level":3,"title":"DNS域名解析过程","slug":"dns域名解析过程","link":"#dns域名解析过程","children":[]},{"level":3,"title":"比较常见的状态码","slug":"比较常见的状态码","link":"#比较常见的状态码","children":[]},{"level":3,"title":"队头阻塞","slug":"队头阻塞","link":"#队头阻塞","children":[]},{"level":3,"title":"Cookie","slug":"cookie","link":"#cookie","children":[]}]}],"relativePath":"article/daily-study/2022/september/9.28-复习一.md"}'),d={name:"article/daily-study/2022/september/9.28-复习一.md"},r=t('<h1 id="_9-28-复习一" tabindex="-1">9.28-复习一 <a class="header-anchor" href="#_9-28-复习一" aria-hidden="true">#</a></h1><h2 id="复习的知识" tabindex="-1"><strong>复习的知识</strong> <a class="header-anchor" href="#复习的知识" aria-hidden="true">#</a></h2><h3 id="http的发展历程" tabindex="-1"><strong>HTTP的发展历程</strong> <a class="header-anchor" href="#http的发展历程" aria-hidden="true">#</a></h3><ul><li>HTTP协议开始于三十年前蒂姆·伯纳斯 - 李的一篇论文</li><li>1989, HTTP/0.9</li><li>1996, HTTP/1.0</li><li>1999, HTTP/1.1</li><li>2015, HTTP/2 (<code>从HTTP/2开始,取消了小版本号，所以 HTTP/2 的正式名字不是 2.0</code>)</li><li>2018, HTTP/3</li></ul><p><strong>HTTP/2.0</strong> 相比较 <strong>HTTP/1.1</strong></p><p>2015年, 发布了 <strong>HTTP/2</strong>, <strong>HTTP/2</strong> 的制定充分考虑了现今互联网的现状:宽带、移动、不安全，在高度兼容</p><ul><li>二进制协议，不再是纯文本(<code>二进制协议</code>)</li><li>可发起多个请求，废弃了 1.1 里的管道(<code>多路复用</code>)</li><li>使用专用算法压缩头部，减少数据传输量(<code>头部压缩, 使得可以在header带更多数据了</code>)</li><li>允许服务器主动向客户端推送数据(<code>服务器主动push数据到客户端</code>)</li><li>增强了安全性，“事实上”要求加密通信(<code>安全性</code>)</li></ul><h3 id="域名的形式" tabindex="-1"><strong>域名的形式</strong> <a class="header-anchor" href="#域名的形式" aria-hidden="true">#</a></h3><p>域名是一个有层次的结构，是一串用.分隔的多个单词，最右边的 被称为顶级域名，然后是二级域名，层级关系向左依次降低。</p><p>最左边的是主机名，通常用来表明主机的用途，比如www表示提供万维网服 务、mail表示提供邮件服务，不过这也不是绝对的，名字的关键是要让我们容易记忆。</p><p>例如: www.codevity.top</p><ul><li>top就是顶级域名，</li><li>codevity是二级域名</li><li>www则是主机名。</li><li>使用这个域名，DNS 就会把它转换成相应的 IP 地址，你就我的网站了。</li></ul><h3 id="dns域名解析过程" tabindex="-1"><strong>DNS域名解析过程</strong> <a class="header-anchor" href="#dns域名解析过程" aria-hidden="true">#</a></h3><ul><li>先查看<code>浏览器</code>查询是否有缓存,如果没有</li><li>然后看<code>host文件</code>查询是否有缓存, 如果没有</li><li>再看<code>操作系统</code>查询是否有缓存, 如果没有</li><li>然后再去<code>非权威域名服务器</code>查询是否有缓存, 如果没有</li><li>最后查询<code>根域名</code> -&gt; <code>顶级域名</code> -&gt;<code>权威域名服务器</code></li><li>如果都没有, 网站错误,</li><li>如果存在,继续加载网站</li></ul><h3 id="比较常见的状态码" tabindex="-1"><strong>比较常见的状态码</strong> <a class="header-anchor" href="#比较常见的状态码" aria-hidden="true">#</a></h3><p>2××类状态码表示服务器收到并成功处理了客户端的请求， 这也是客户端最愿意看到的状态码。</p><ul><li><code>200请求成功</code></li><li><code>204请求成功, 但是没有body数据</code></li><li><code>206请求成功, 返回部分数据(分断上传时会用到)</code></li></ul><p>3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的重定向，包括著名的 301、302 跳转。</p><ul><li><code>301永久重定向</code></li><li><code>302临时重定向</code></li><li><code>304重定向到缓存文件</code></li></ul><p>4××类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的错误码含义了。</p><ul><li><code>400通用客户端错误(可能是报文错误,也可能是url等等的错误)</code></li><li><code>401未授权token</code></li><li><code>403服务器禁止访问</code></li><li><code>404在服务器上未找到资源</code></li><li><code>405不允许使用某些方法操作资源</code></li></ul><p>5××类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的错误码。</p><ul><li><code>500通用服务端错误</code></li><li><code>501客户端请求功能不支持</code></li><li><code>502访问服务器时发生错误</code></li><li><code>503服务器很忙,暂时无法响应服务</code></li></ul><h3 id="队头阻塞" tabindex="-1"><strong>队头阻塞</strong> <a class="header-anchor" href="#队头阻塞" aria-hidden="true">#</a></h3><p>因为 HTTP 规定报文必须是一发一收，这就形成了一个 先进先出的串行队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</p><p>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</p><img src="'+e+'" alt="image-20220912225450540" style="zoom:50%;"><p>解决队头阻塞问题的方法</p><ul><li><strong>并发连接</strong>，也就是同时对一个域名发起多个长连接(现在可以一次并发6~8个)， 用数量来解决质量的问题, 可以解决此问题。</li><li><strong>域名分片</strong>, 也就是多个域名指向同一台服务器</li></ul><h3 id="cookie" tabindex="-1"><strong>Cookie</strong> <a class="header-anchor" href="#cookie" aria-hidden="true">#</a></h3><p><code>Cookie是为了给http增加记忆能力</code></p><p><strong>Cookie的属性</strong></p><ul><li><p>Cookie 的有效期可以使用<code> Expires</code> 和 <code>Max-Age</code> 两个属性来设置。</p><p><strong>Expires</strong>俗称过期时间，用的是绝对时间点，可以理解为截止日 期(deadline)。<strong>Max-Age</strong>用的是相对时间，单位是秒，浏览器用收到报文的时间 点再加上 Max-Age，就可以得到失效的绝对时间。</p><p>Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会<code>优先采用 Max-Age </code>计算失效期。</p></li><li><p><strong>设置 Cookie 的作用域</strong>，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。</p><p>作用域的设置比较简单，<strong>Domain</strong>和<strong>Path</strong>指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。</p><p>使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如/19-1用一个 Cookie，/19-2再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个/或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器 自己去挑。</p></li><li><p><strong>Cookie 的安全性</strong></p><p>在 JS 脚本里可以用 document.cookie 来读写 Cookie 数据，这就带来了安全隐患，有可能会导致跨站脚本(XSS)攻击窃取数据。</p><p>属性<strong>HttpOnly</strong>会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也 就无从谈起了。</p><p>另一个属性<strong>SameSite</strong>可以防范跨站请求伪造(XSRF)攻击，设置 成SameSite=Strict可以严格限定 Cookie 不能随着跳转链接跨站发送， 而SameSite=Lax则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发送。</p><p>还有一个属性叫<strong>Secure</strong>，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</p></li></ul><p>上述所有属性: <code>Expires、Max-Age、Domain、Path、HttpOnly、SameSite、Secure</code></p>',34),c=[r];function a(n,s,p,h,g,u){return l(),i("div",null,c)}const P=o(d,[["render",a]]);export{k as __pageData,P as default};
