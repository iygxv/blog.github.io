import{_ as e,c as a,o as d,a as c}from"./app.f58bd366.js";const f=JSON.parse('{"title":"8.14-总结本周数组API","description":"","frontmatter":{},"headers":[{"level":2,"title":"reduce总结","slug":"reduce总结","link":"#reduce总结","children":[]},{"level":2,"title":"flat总结","slug":"flat总结","link":"#flat总结","children":[]},{"level":2,"title":"map总结","slug":"map总结","link":"#map总结","children":[]},{"level":2,"title":"includes总结","slug":"includes总结","link":"#includes总结","children":[]},{"level":2,"title":"at总结","slug":"at总结","link":"#at总结","children":[]}],"relativePath":"article/daily-study/2022/august/8.14-总结本周数组API.md"}'),l={name:"article/daily-study/2022/august/8.14-总结本周数组API.md"},t=c('<h1 id="_8-14-总结本周数组api" tabindex="-1">8.14-总结本周数组API <a class="header-anchor" href="#_8-14-总结本周数组api" aria-hidden="true">#</a></h1><h2 id="reduce总结" tabindex="-1">reduce总结 <a class="header-anchor" href="#reduce总结" aria-hidden="true">#</a></h2><ul><li>没有传入<code>callbackFn</code>会报错</li><li>传入<code>callbackFn</code>非函数也会报错</li><li>如果有<code>initialValue</code>, 则会被作为初始值, 没有则会取数组的第一位作为初始值(数组必须有长度)</li><li>数组循环的处理, 我们要做的就是将每次循环的<code>callbackFn</code>参数给到就行</li></ul><h2 id="flat总结" tabindex="-1">flat总结 <a class="header-anchor" href="#flat总结" aria-hidden="true">#</a></h2><p>实现<code>flat</code>方法主要是使用递归</p><p><code>Infinity</code>是比任何数字都大的, 所以<code>当depth为Infinity时 depth &gt; 0</code>永远成立</p><h2 id="map总结" tabindex="-1">map总结 <a class="header-anchor" href="#map总结" aria-hidden="true">#</a></h2><p>实现<code>map</code>方法主要是将每次callback执行的结果给到新数组</p><h2 id="includes总结" tabindex="-1">includes总结 <a class="header-anchor" href="#includes总结" aria-hidden="true">#</a></h2><p>实现<code>includes</code>方法主要通过<code>Object.is</code>来判断相等的问题</p><h2 id="at总结" tabindex="-1">at总结 <a class="header-anchor" href="#at总结" aria-hidden="true">#</a></h2><p><code>Math.trunc() </code>方法会将数字的小数部分去掉，只保留整数部分</p><p>实现<code>at</code>的方法也很容易, 主要是拿到对应元素的索引, 然后拿值</p>',13),i=[t];function r(n,o,s,h,u,_){return d(),a("div",null,i)}const m=e(l,[["render",r]]);export{f as __pageData,m as default};
