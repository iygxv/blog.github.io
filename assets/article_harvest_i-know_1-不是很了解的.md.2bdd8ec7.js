import{_ as s,c as e,o as n,a}from"./app.f58bd366.js";const y=JSON.parse('{"title":"我想知道","description":"","frontmatter":{},"headers":[{"level":2,"title":"1.运行 npm run xxx 的时候发生了什么？","slug":"_1-运行-npm-run-xxx-的时候发生了什么","link":"#_1-运行-npm-run-xxx-的时候发生了什么","children":[]},{"level":2,"title":"2. npm 的语义化版本（Semver）","slug":"_2-npm-的语义化版本-semver","link":"#_2-npm-的语义化版本-semver","children":[]},{"level":2,"title":"3.前端水印功能是怎么实现的吗","slug":"_3-前端水印功能是怎么实现的吗","link":"#_3-前端水印功能是怎么实现的吗","children":[]},{"level":2,"title":"4. 一键登录原理","slug":"_4-一键登录原理","link":"#_4-一键登录原理","children":[]},{"level":2,"title":"5.require() 源码解读","slug":"_5-require-源码解读","link":"#_5-require-源码解读","children":[{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"6.Git 使用规范流程","slug":"_6-git-使用规范流程","link":"#_6-git-使用规范流程","children":[]},{"level":2,"title":"7.修改node_modules包代码","slug":"_7-修改node-modules包代码","link":"#_7-修改node-modules包代码","children":[]},{"level":2,"title":"8.line-height:1是什么意思","slug":"_8-line-height-1是什么意思","link":"#_8-line-height-1是什么意思","children":[]},{"level":2,"title":"9.本地项目连接远程仓库","slug":"_9-本地项目连接远程仓库","link":"#_9-本地项目连接远程仓库","children":[]},{"level":2,"title":"10.npx相关","slug":"_10-npx相关","link":"#_10-npx相关","children":[]},{"level":2,"title":"11.vue2中sync修饰符","slug":"_11-vue2中sync修饰符","link":"#_11-vue2中sync修饰符","children":[]},{"level":2,"title":"12. 如何删除项目中没有使用到的 package","slug":"_12-如何删除项目中没有使用到的-package","link":"#_12-如何删除项目中没有使用到的-package","children":[]}],"relativePath":"article/harvest/i-know/1-不是很了解的.md"}'),l={name:"article/harvest/i-know/1-不是很了解的.md"},o=a(`<h1 id="我想知道" tabindex="-1">我想知道 <a class="header-anchor" href="#我想知道" aria-hidden="true">#</a></h1><p>不知道能坚持多久, 先试试吧, 总比啥也不做好 <code>我想知道学习笔记</code>记录:</p><ul><li>在工作中, 生活上, 掘金等多个地方认识到的知识</li><li>偏向于不懂的知识</li></ul><h2 id="_1-运行-npm-run-xxx-的时候发生了什么" tabindex="-1">1.运行 npm run xxx 的时候发生了什么？ <a class="header-anchor" href="#_1-运行-npm-run-xxx-的时候发生了什么" aria-hidden="true">#</a></h2><ul><li>运行<code>npm run xxx</code>的时候，npm 会先在当前目录的 <code>node_modules/.bin</code> 查找要执行的程序，如果找到则运行</li><li>没有找到则从全局的 node_modules/.bin 中查找</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序</li></ul><p><a href="https://blog.51cto.com/u_15077533/4531157" target="_blank" rel="noreferrer">去学习</a></p><h2 id="_2-npm-的语义化版本-semver" tabindex="-1">2. npm 的语义化版本（Semver） <a class="header-anchor" href="#_2-npm-的语义化版本-semver" aria-hidden="true">#</a></h2><p><strong>标准的版本号必须采用 X.Y.Z 的格式</strong>，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。<strong>X 是主版本号、Y 是次版本号、而 Z 为修订号，英文对应表示为 major、minor、patch</strong>，每个元素必须以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</p><p><a href="https://juejin.cn/post/7133175128988319775" target="_blank" rel="noreferrer">去学习</a></p><h2 id="_3-前端水印功能是怎么实现的吗" tabindex="-1">3.前端水印功能是怎么实现的吗 <a class="header-anchor" href="#_3-前端水印功能是怎么实现的吗" aria-hidden="true">#</a></h2><p><strong>三种实现方案</strong></p><ul><li><p><strong>第一种: 基于原图生成水印图片（后端）</strong></p><p>这种方案就是将 <strong>原图片</strong> 添加水印之后生成了 <strong>新图片</strong>，后续在前端页面进行展示是后端接口不返回原图片，而是返回带有水印的图片即可。</p><p>这种方式最大的优点就是安全，因为 <strong>水印图片</strong> 是后端生成的，前端只需要负责展示即可，不需考虑多余的问题，且即便在前端页面保存对应图片，拿到的仍然不是原图片</p></li><li><p><strong>第二种: 基于 DOM 实现水印效果（前端）</strong></p><p>自定义指令钩子非常多，但实际上能使用到的不多，比如最常用的就是 <code>mounted</code>、<code>updated</code>，在这我们只需要通过 <code>mounted</code> 即可实现对应的功能，并且核心代码比较简单。</p><p><strong>核心内容</strong></p><p>创建一个 <code>watermark</code> 的 <code>DOM</code> 节点，即 <code>div</code> 元素，用于包裹对应的 <code>img</code> 便于展示水印内容</p><p>在创建一个 <code>waterbg</code> 的 <code>DOM</code> 节点，即 <code>div</code> 元素</p><ul><li>将 <code>waterbg</code> 节点作为 <code>watermark</code> 的 <strong>子节点</strong>，并进行 <strong>绝对定位</strong> 保证 <code>waterbg</code> 在 <strong>最上层显示</strong></li><li>将对应的 <strong>水印标记</strong> 作为 <code>waterbg</code> 节点的 <strong>背景图片</strong> 展示</li><li>为 <code>waterbg</code> 节点设置 <code>pointer-events: none;</code> 实现 <strong>点击穿透</strong></li></ul><p>将 <code>watermark</code> 节点通过 <code>insertBefore(...)</code> 插入到 <code>img</code> 标签的前一个位置</p><p>再将 <code>img</code> 标签移动到 <code>watermark</code> 节点节中，这样就保证了新创建的 <code>watermark</code> 节点的位置一定是在原本 <code>img</code> 挂载的位置</p></li><li><p><strong>第三种: 基于 Canvas 实现水印效果（前端）</strong></p><p>基于 <code>Canvas</code> 实现方式的优点就在于能够动态的设置水印内容，相比于上一种基于固定背景图片的方式更灵活，这种方式也是 <strong>语雀</strong> 在使用的方式</p><p><strong>核心步骤</strong></p><p>通过 <code>canvas</code> 填充文本，并通过 <code>canvas.toDataURL(&quot;image/png&quot;);</code> 获取到对应的 <code>base64</code> 格式的图片</p><p>将这个 <code>base64</code> 格式的图片作为类名为 <code>water-mark</code> 节点的背景图</p><ul><li>利用 <code>background-repeat: repeat;</code> 让这个图重复填充背景即可</li><li>为 <code>water-mark</code> 节点设置 <code>pointer-events: none;</code> 实现 <strong>点击穿透</strong></li><li>利用对应图片的父元素作为 <code>water-mark</code> 节点的相对定位节点，保证绝对定位的 <code>water-mark</code> 节点显式在对应图片之上</li></ul><p><a href="https://juejin.cn/post/7132620574198595597#heading-0" target="_blank" rel="noreferrer">去学习</a></p></li></ul><h2 id="_4-一键登录原理" tabindex="-1">4. 一键登录原理 <a class="header-anchor" href="#_4-一键登录原理" aria-hidden="true">#</a></h2><p><a href="https://juejin.cn/post/7059182505101885471#heading-5" target="_blank" rel="noreferrer">去学习</a></p><h2 id="_5-require-源码解读" tabindex="-1">5.require() 源码解读 <a class="header-anchor" href="#_5-require-源码解读" aria-hidden="true">#</a></h2><p><code>当 Node 遇到 require(X) 时，按下面的顺序处理</code></p><ol><li><p>如果 X 是内置模块（比如 require(&#39;http&#39;）)</p><ul><li>a. 返回该模块</li><li>b. 不再继续执行</li></ul></li><li><p>如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头</p><ul><li>a. 根据 X 所在的父模块，确定 X 的绝对路径</li><li>b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">X</span></span>
<span class="line"><span style="color:#A6ACCD;">X</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">X</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"><span style="color:#A6ACCD;">X</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">node</span></span>
<span class="line"></span></code></pre></div><ul><li>c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">X</span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">package</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json（main字段）</span></span>
<span class="line"><span style="color:#A6ACCD;">X</span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">X</span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">json</span></span>
<span class="line"><span style="color:#A6ACCD;">X</span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">node</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div></li><li><p>如果 X 不带路径</p><ul><li>a. 根据 X 所在的父模块，确定 X 可能的安装目录</li><li>b. 依次在每个目录中，将 X 当成文件名或目录名加载</li></ul></li><li><p>抛出 &quot;not found&quot;</p></li></ol><p>请看一个例子。</p><p>当前脚本文件 /home/ry/projects/foo.js 执行了 require(&#39;bar&#39;) ，这属于上面的第三种情况。Node 内部运行过程如下。</p><p>首先，确定 x 的绝对路径可能是下面这些位置，依次搜索每一个目录。</p><blockquote><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">/home/ry/projects/node_modules/bar</span></span>
<span class="line"><span style="color:#FFCB6B;">/home/ry/node_modules/bar</span></span>
<span class="line"><span style="color:#FFCB6B;">/home/node_modules/bar</span></span>
<span class="line"><span style="color:#FFCB6B;">/node_modules/bar</span></span>
<span class="line"></span></code></pre></div></blockquote><p>搜索时，Node 先将 bar 当成文件名，依次尝试加载下面这些文件，只要有一个成功就返回。</p><blockquote><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">bar</span></span>
<span class="line"><span style="color:#FFCB6B;">bar.js</span></span>
<span class="line"><span style="color:#FFCB6B;">bar.json</span></span>
<span class="line"><span style="color:#FFCB6B;">bar.node</span></span>
<span class="line"></span></code></pre></div></blockquote><p>如果都不成功，说明 bar 可能是目录名，于是依次尝试加载下面这些文件。</p><blockquote><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">bar/package.json（main字段）</span></span>
<span class="line"><span style="color:#FFCB6B;">bar/index.js</span></span>
<span class="line"><span style="color:#FFCB6B;">bar/index.json</span></span>
<span class="line"><span style="color:#FFCB6B;">bar/index.node</span></span>
<span class="line"></span></code></pre></div></blockquote><p>如果在所有目录中，都无法找到 bar 对应的文件或目录，就抛出一个错误。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h3><ul><li>内置模块(<code>自带的</code>)</li><li>本地模块(<code>以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头</code>)</li><li>依赖模块(<code>不带路径</code>)</li><li>不存在报错</li></ul><p><a href="https://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noreferrer">去学习</a></p><h2 id="_6-git-使用规范流程" tabindex="-1">6.Git 使用规范流程 <a class="header-anchor" href="#_6-git-使用规范流程" aria-hidden="true">#</a></h2><p><a href="https://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noreferrer">去学习</a></p><h2 id="_7-修改node-modules包代码" tabindex="-1">7.修改node_modules包代码 <a class="header-anchor" href="#_7-修改node-modules包代码" aria-hidden="true">#</a></h2><p>使用<code>patch-package</code></p><p>这是一个专门用来修改<code>node_modules</code>中包的代码的工具</p><p>理解</p><ul><li>给包打上补丁</li><li>使用命令 <code>&quot;postinstall&quot;: &quot;patch-package&quot;</code></li><li>当你的同事去执行<code>yarn</code>的时候，会自动执行<code>yarn postinstall</code>这个命令，也就是执行<code>patch-package</code>，这时候就回去读取刚刚的<code>patches</code>目录，并将那些补丁达到对应的包里</li></ul><p><a href="https://mp.weixin.qq.com/s/FwNubmS8k5j9F5xiTzQ6oQ" target="_blank" rel="noreferrer">去学习</a></p><h2 id="_8-line-height-1是什么意思" tabindex="-1">8.line-height:1是什么意思 <a class="header-anchor" href="#_8-line-height-1是什么意思" aria-hidden="true">#</a></h2><p>其实是设置行高的一种方法，只不过简化了语句</p><p>举个例子，比如此时你设置了font-size：20px，之后你设置了line-height:1，转义过来的意思就是line-height:20px</p><h2 id="_9-本地项目连接远程仓库" tabindex="-1">9.本地项目连接远程仓库 <a class="header-anchor" href="#_9-本地项目连接远程仓库" aria-hidden="true">#</a></h2><ul><li>先在本地仓库初始化( <code>git init</code>)</li><li>关联远程仓库(<code>git remote add origin 远程地址</code>)</li><li>推送远程git push -u origin master</li></ul><h2 id="_10-npx相关" tabindex="-1">10.npx相关 <a class="header-anchor" href="#_10-npx相关" aria-hidden="true">#</a></h2><p>Node安装后自带npm模块，可以直接使用npx命令</p><p>npx 可以让项目内部安装的模块</p><p>npx 的原理: 运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在</p><p><strong>npx与npm的区别</strong></p><ul><li><p>npx 会自动查找当前依赖包中的[可执行文件)</p></li><li><p>npx可以执行文件，但是npm不可以</p></li></ul><h2 id="_11-vue2中sync修饰符" tabindex="-1">11.vue2中sync修饰符 <a class="header-anchor" href="#_11-vue2中sync修饰符" aria-hidden="true">#</a></h2><p>什么情况下用sync修饰符</p><ul><li>需要对一个 prop 进行<code>双向绑定</code></li></ul><p><strong>父组件</strong></p><p><code>原本应该这样写</code></p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">text-document</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#C792EA;">v-bind:title</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">doc.title</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#C792EA;">v-on:update:title</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">doc.title = $event</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">text-document</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p><code>简写</code></p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">text-document</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-bind:title.sync</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">doc.title</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">text-document</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p><strong>子组件</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">$emit</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">update:title</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> newTitle)</span></span>
<span class="line"></span></code></pre></div><p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。</p><h2 id="_12-如何删除项目中没有使用到的-package" tabindex="-1">12. 如何删除项目中没有使用到的 package <a class="header-anchor" href="#_12-如何删除项目中没有使用到的-package" aria-hidden="true">#</a></h2><p>可以采用 depcheck 来完成这件事</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">$</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">depcheck</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-g</span></span>
<span class="line"><span style="color:#FFCB6B;">$</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">npx</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">depcheck</span></span>
<span class="line"><span style="color:#FFCB6B;">Missing</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">dependencies</span></span>
<span class="line"><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> lodash</span></span>
<span class="line"></span></code></pre></div>`,62),p=[o];function t(c,r,i,d,h,u){return n(),e("div",null,p)}const D=s(l,[["render",t]]);export{y as __pageData,D as default};
