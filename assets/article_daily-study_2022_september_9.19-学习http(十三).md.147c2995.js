import{_ as e}from"./chunks/image-20220919145943462.45d39c9f.js";import{_ as t,c as r,o as s,a as n}from"./app.f58bd366.js";const i="/assets/image-20220919181001505.cd575db3.png",p="/assets/image-20220919181330179.a8f28244.png",a="/assets/image-20220919181812092.31fe3064.png",l="/assets/image-20220919183424984.658f907c.png",o="/assets/image-20220919183627274.34f4c571.png",h="/assets/image-20220919183924370.6681f123.png",P=JSON.parse('{"title":"9.19-学习http(十三)","description":"","frontmatter":{},"headers":[{"level":2,"title":"HTTPS是什么? SSL/TLS又是什么?","slug":"https是什么-ssl-tls又是什么","link":"#https是什么-ssl-tls又是什么","children":[{"level":3,"title":"为什么要有HTTPS?","slug":"为什么要有https","link":"#为什么要有https","children":[]},{"level":3,"title":"什么是安全?","slug":"什么是安全","link":"#什么是安全","children":[]},{"level":3,"title":"什么是HTTPS?","slug":"什么是https","link":"#什么是https","children":[]},{"level":3,"title":"SSL/TLS","slug":"ssl-tls","link":"#ssl-tls","children":[]},{"level":3,"title":"OpenSSL","slug":"openssl","link":"#openssl","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":2,"title":"对称加密与非对称加密","slug":"对称加密与非对称加密","link":"#对称加密与非对称加密","children":[{"level":3,"title":"对称加密","slug":"对称加密","link":"#对称加密","children":[]},{"level":3,"title":"非对称加密","slug":"非对称加密","link":"#非对称加密","children":[]},{"level":3,"title":"混合加密","slug":"混合加密","link":"#混合加密","children":[]},{"level":3,"title":"小结","slug":"小结-1","link":"#小结-1","children":[]}]},{"level":2,"title":"数字签名与证书","slug":"数字签名与证书","link":"#数字签名与证书","children":[{"level":3,"title":"摘要算法","slug":"摘要算法","link":"#摘要算法","children":[]},{"level":3,"title":"完整性","slug":"完整性","link":"#完整性","children":[]},{"level":3,"title":"数字签名","slug":"数字签名","link":"#数字签名","children":[]},{"level":3,"title":"数字证书和 CA","slug":"数字证书和-ca","link":"#数字证书和-ca","children":[]},{"level":3,"title":"证书体系的弱点","slug":"证书体系的弱点","link":"#证书体系的弱点","children":[]},{"level":3,"title":"小结","slug":"小结-2","link":"#小结-2","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"relativePath":"article/daily-study/2022/september/9.19-学习http(十三).md"}'),d={name:"article/daily-study/2022/september/9.19-学习http(十三).md"},g=n('<h1 id="_9-19-学习http-十三" tabindex="-1">9.19-学习http(十三) <a class="header-anchor" href="#_9-19-学习http-十三" aria-hidden="true">#</a></h1><h2 id="https是什么-ssl-tls又是什么" tabindex="-1"><strong>HTTPS是什么? SSL/TLS又是什么?</strong> <a class="header-anchor" href="#https是什么-ssl-tls又是什么" aria-hidden="true">#</a></h2><h3 id="为什么要有https" tabindex="-1"><strong>为什么要有HTTPS?</strong> <a class="header-anchor" href="#为什么要有https" aria-hidden="true">#</a></h3><p>简单的回答是<strong>因为 HTTP 不安全</strong>。</p><p>由于 HTTP 天生明文的特点，整个传输过程完全透明，任何人都能够在链路中截获、 修改或者伪造请求 / 响应报文，数据不具有可信性。</p><h3 id="什么是安全" tabindex="-1"><strong>什么是安全?</strong> <a class="header-anchor" href="#什么是安全" aria-hidden="true">#</a></h3><p>既然 HTTP不安全，那什么样的通信过程才是安全的呢? 通常认为，如果通信过程具备了四个特性，就可以认为是安全的，这四个特性是:</p><ul><li>机密性</li><li>完整性</li><li>身份认证</li><li>不可否认</li></ul><p><strong>机密性</strong>(Secrecy/Confidentiality)是指对数据的保密，只能由可信的人访问，对其他人是不可见的秘密，简单来说就是不能让不相关的人看到不该看的东西。</p><p><strong>完整性</strong>(Integrity，也叫一致性)是指数据在传输过程中没有被窜改，不多也不少，完完整整地保持着原状。</p><p><strong>身份认证</strong>(Authentication)是指确认对方的真实身份，也就是证明你真的是你，保证消息只能发送给可信的人。</p><p>第四个特性是<strong>不可否认</strong>(Non-repudiation/Undeniable)，也叫不可抵赖，意思是不能否认已经发生过的行为，不能说话不算数耍赖皮。</p><p>使用前三个特性，可以解决安全通信的大部分问题，但如果缺了不可否认，那通信的事务真实性就得不到保证，有可能出现老赖。</p><p>所以，只有同时具备了机密性、完整性、身份认证、不可否认这四个特性，通信双方的利益才能有保障，才能算得上是真正的安全。</p><h3 id="什么是https" tabindex="-1"><strong>什么是HTTPS?</strong> <a class="header-anchor" href="#什么是https" aria-hidden="true">#</a></h3><p>HTTPS 其实是一个非常简单的协议，RFC 文档很小，只有短短的 7 页，里面规定了<strong>新的协议名https，默认端口号 443</strong>，至于其他的什么请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP，没有任何新的东西。</p><p>HTTPS 把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由<strong>HTTP over TCP/IP</strong>变成了<strong>HTTP over SSL/TLS</strong>，让 HTTP 运行在了安全的 SSL/TLS 协议上，收发报文不再使用 Socket API， 而是调用专门的安全接口。</p><img src="'+e+'" alt="image-20220919145943462" style="zoom:50%;"><p>所以说，HTTPS 本身并没有什么惊世骇俗的本事，全是靠着后面的 SSL/TLS撑腰。只要学会了 SSL/TLS，HTTPS 自然就手到擒来。</p><h3 id="ssl-tls" tabindex="-1"><strong>SSL/TLS</strong> <a class="header-anchor" href="#ssl-tls" aria-hidden="true">#</a></h3><p>SSL 即安全套接层(Secure Sockets Layer)，在 OSI 模型中处于第 5 层(会话层)，由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。</p><p>SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF <code>在 1999 年</code>把它改名为 TLS(传输层安全，Transport Layer Security)，正式标准化，版本号从 1.0 重新算起，所以<code> TLS1.0 实际上就是 SSLv3.1</code>。</p><p>到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年 (2018)的 1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性 能，已经成为了信息安全领域中的权威标准。</p><p>目前应用的<code>最广泛的 TLS 是 1.2</code>，而之前的协议(TLS1.1/1.0、SSLv3/v2)都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 TLS1.2。</p><p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成， 综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p><h3 id="openssl" tabindex="-1"><strong>OpenSSL</strong> <a class="header-anchor" href="#openssl" aria-hidden="true">#</a></h3><p>说到 TLS，就不能不谈到 OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</p><p>OpenSSL 是从另一个开源库 SSLeay 发展出来的，曾经考虑命名为OpenTLS，但当时 (1998 年)TLS 还未正式确立，而 SSL 早已广为人知，所以最终使用了OpenSSL的名字。</p><h3 id="小结" tabindex="-1"><strong>小结</strong> <a class="header-anchor" href="#小结" aria-hidden="true">#</a></h3><ul><li>因为 HTTP 是明文传输，所以不安全，容易被黑客窃听或窜改</li><li>通信安全必须同时<code>具备机密性、完整性，身份认证和不可否认这四个特性</code></li><li>HTTPS 的语法、语义仍然是 HTTP，但<code>把下层的协议由 TCP/IP 换成了 SSL/TLS</code></li><li>SSL/TLS 是信息安全领域中的权威标准，采用多种先进的加密技术保证通信安全</li><li>OpenSSL 是著名的开源密码学工具包，是 SSL/TLS 的具体实现</li></ul><h2 id="对称加密与非对称加密" tabindex="-1"><strong>对称加密与非对称加密</strong> <a class="header-anchor" href="#对称加密与非对称加密" aria-hidden="true">#</a></h2><p>在上面, 我们初步学习了 HTTPS，知道 HTTPS 的安全性是由 TLS 来保证的。</p><p>你一定很好奇，它是怎么为 HTTP 增加了机密性、完整性，身份认证和不可否认等特性的呢?</p><p>先说说机密性。它是信息安全的基础，缺乏机密性 TLS 就会成为无水之源、无根之木。</p><p>实现机密性最常用的手段是<strong>加密</strong>(encrypt)，就是把消息用某种方式转换成谁也看不懂的乱码，只有掌握特殊钥匙的人才能再转换出原始文本。</p><p>这里的钥匙就叫做<strong>密钥</strong>(key)，加密前的消息叫<strong>明文</strong>(plain text/clear text)，加密后的乱码叫<strong>密文</strong>(cipher text)，使用密钥还原明文的过程叫<strong>解 密</strong>(decrypt)，是加密的反操作，加密解密的操作过程就是<strong>加密算法</strong>。</p><p>所有的加密算法都是公开的，任何人都可以去分析研究，而算法使用的密钥则必须保密。那么，这个关键的密钥又是什么呢?</p><p>由于 HTTPS、TLS 都运行在计算机上，所以密钥就是一长串的数字，但约定俗成的度 量单位是位(bit)，而不是字节(byte)。比如，说密钥长度是 128，就是 16 字节的二进制串，密钥长度 1024，就是 128 字节的二进制串。</p><p>按照密钥的使用方式，加密可以分为两大类:<strong>对称加密和非对称加密</strong>。</p><h3 id="对称加密" tabindex="-1"><strong>对称加密</strong> <a class="header-anchor" href="#对称加密" aria-hidden="true">#</a></h3><p>对称加密很好理解，就是指<code>加密和解密时使用的密钥</code>都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</p><p>举个例子，你想要登录某网站，只要事先和它约定好使用一个对称密码，通信过程中传输的全是用密钥加密后的密文，只有你和网站才能解密。黑客即使能够窃听，看到的也只是乱码，因为没有密钥无法解出明文，所以就实现了机密性。</p><img src="'+i+'" alt="image-20220919181001505" style="zoom:50%;"><p>TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。</p><p>AES 的意思是高级加密标准(Advanced Encryption Standard)，密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化，所以非常流行，是应用最广泛的对称加密算法。</p><p>ChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能 要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所 以现在不再具有明显的优势，但仍然算得上是一个不错算法。</p><h3 id="非对称加密" tabindex="-1"><strong>非对称加密</strong> <a class="header-anchor" href="#非对称加密" aria-hidden="true">#</a></h3><p>对称加密看上去好像完美地实现了机密性，但其中有一个很大的问题:如何把密钥安全地传递给对方，术语叫<strong>密钥交换</strong>。</p><p>因为在对称加密算法中只要持有密钥就可以解密。如果你和网站约定的密钥在传递途中被黑客窃取，那他就可以在之后随意解密收发的数据，通信过程也就没有机密性可言了。</p><p>这个问题该怎么解决呢?</p><p>你或许会说:把密钥再加密一下发过去就好了，但传输加密密钥的密钥又成了新问题。这就像是鸡生蛋、蛋生鸡，可以无限递归下去。只用对称加密算法，是绝对无法解决密钥交换的问题的。所以，就出现了非对称加密(也叫公钥加密算法)。</p><p>它有两个密钥，一个叫<strong>公钥</strong>(public key)，一个叫<strong>私钥</strong>(private key)。两个密钥是不同的，不对称，<code>公钥可以公开给任何人使用，而私钥必须严格保密</code>。</p><p>公钥和私钥有个特别的<strong>单向</strong>性，虽然都可以用来加密解密，但公钥加密后只能用私钥解 密，反过来，私钥加密后也只能用公钥解密。</p><p><code>非对称加密可以解决密钥交换的问题</code>。网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。</p><img src="'+p+'" alt="image-20220919181330179" style="zoom:50%;"><p>非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 DH、 DSA、RSA、ECC 等。</p><p>RSA 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于<strong>整数分解</strong>的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私 钥是非常困难的。</p><p>10 年前 RSA 密钥的推荐长度是 1024，但随着计算机运算能力的提高，现在 1024 已经不安全，普遍认为至少要 2048 位。</p><p>ECC(Elliptic Curve Cryptography)是非对称加密里的后起之秀，它基于<strong>椭圆曲线离散对数</strong>的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于 密钥交换，ECDSA 用于数字签名。</p><p>目前比较常用的两个曲线是 P-256(secp256r1，在 OpenSSL 称为 prime256v1)和 x25519。P-256 是 NIST(美国国家标准技术研究所)和 NSA(美国国家安全局)推荐使 用的曲线，而 x25519 被认为是最安全、最快速的曲线。</p><p>比起 RSA，ECC 在安全强度和性能上都有明显的优势。160 位的 ECC 相当于 1024 位的 RSA，而 224 位的 ECC 则相当于 2048 位的 RSA。因为密钥短，所以相应的计算量、消耗 的内存和带宽也就少，加密解密的性能就上去了，对于现在的移动互联网非常有吸引力。</p><h3 id="混合加密" tabindex="-1"><strong>混合加密</strong> <a class="header-anchor" href="#混合加密" aria-hidden="true">#</a></h3><p>看到这里，你是不是认为可以抛弃对称加密，只用非对称加密来实现机密性呢?</p><p>很遗憾，虽然非对称加密没有密钥交换的问题，但因为它们都是基于复杂的数学难题， 运算速度很慢，即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零。</p><p>那么，是不是能够把对称加密和非对称加密结合起来呢，两者互相取长补短，即能高效地加密解密，又能安全地密钥交换。</p><p>这就是现在 TLS 里使用的<strong>混合加密</strong>方式，其实说穿了也很简单:</p><ul><li><p>在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。</p></li><li><p>然后用随机数产生对称算法使用的<strong>会话密钥</strong>(session key)，再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。</p></li><li><p>对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。</p></li></ul><img src="'+a+'" alt="image-20220919181812092" style="zoom:50%;"><p>这样混合加密就解决了对称加密算法的密钥交换问题，而且安全和性能兼顾，完美地实现了机密性。</p><h3 id="小结-1" tabindex="-1"><strong>小结</strong> <a class="header-anchor" href="#小结-1" aria-hidden="true">#</a></h3><ul><li>加密算法的核心思想是把一个小秘密(密钥)转化为一个大秘密(密文消息)，守住了小秘密，也就守住了大秘密</li><li><code>对称加密只使用一个密钥</code>，运算速度快，密钥必须保密，<code>无法做到安全的密钥交换</code>，常用的有 AES 和 ChaCha20</li><li><code>非对称加密使用两个密钥:公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢，常用的有 RSA 和 ECC</code></li><li>把对称加密和非对称加密结合起来就得到了又好又快的混合加密，也就是<code> TLS 里使用的加密方式(混合加密)</code></li></ul><h2 id="数字签名与证书" tabindex="-1"><strong>数字签名与证书</strong> <a class="header-anchor" href="#数字签名与证书" aria-hidden="true">#</a></h2><p>在上面, 我们学习了对称加密和非对称加密，以及两者结合起来的混合加密，实现了机密性。</p><p>但仅有机密性，离安全还差的很远。</p><p>黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能照单全收，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。</p><p>另外，黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和某宝通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在安全的通信过程中被窃取了。</p><p>所以，在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。</p><h3 id="摘要算法" tabindex="-1"><strong>摘要算法</strong> <a class="header-anchor" href="#摘要算法" aria-hidden="true">#</a></h3><p>实现完整性的手段主要是<strong>摘要算法</strong>(Digest Algorithm)，也就是常说的散列函数、哈希函数(Hash Function)。</p><p>你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据压缩成固定长度、而且独一无二的摘要字符串，就好像是给这段数据生成了一个数字指纹。</p><p>换一个角度，也可以把摘要算法理解成特殊的单向加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。</p><p>摘要算法实际上是把数据从一个大空间映射到了小空间，所以就存在冲突(collision，也叫碰撞)的可能性，就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要。好的摘要算法必须能够抵抗冲突，让这种可能性尽量地小。</p><p>因为摘要算法对输入具有单向性和雪崩效应，输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数(PRF，pseudo random function)。</p><p>你一定在日常工作中听过、或者用过 MD5(Message-Digest 5)、SHA-1(Secure Hash Algorithm 1)，它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度 的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。</p><p>目前 TLS 推荐使用的是 SHA-1 的后继者:SHA-2。</p><p>SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、 SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。</p><h3 id="完整性" tabindex="-1"><strong>完整性</strong> <a class="header-anchor" href="#完整性" aria-hidden="true">#</a></h3><p>摘要算法保证了数字摘要和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。</p><p>比如，你发了条消息:转账 1000 元，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份指纹做个对比，如果一致，就说明消息是完整可信的， 没有被修改。</p><p>如果黑客在中间哪怕改动了一个标点符号，摘要也会完全不同，网站计算比对就会发现消息被窜改，是不可信的。不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。</p><p>所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。</p><p>这有个术语，叫哈希消息认证码(HMAC)。</p><img src="'+l+'" alt="image-20220919183424984" style="zoom:50%;"><h3 id="数字签名" tabindex="-1"><strong>数字签名</strong> <a class="header-anchor" href="#数字签名" aria-hidden="true">#</a></h3><p>加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的两个端点(endpoint)。</p><p>就像一开始所说的，黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。</p><p>现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖个章，就能够证明这份文件确实是由本人而不是其他人发出的。</p><p>你回想一下之前的课程，在 TLS 里有什么东西和现实中的签名、印章很像，只能由本人持有，而其他任何人都不会有呢?只要用这个东西，就能够在数字世界里证明你的身份。</p><p>没错，这个东西就是非对称加密里的<strong>私钥</strong>，使用私钥再加上摘要算法，就能够实现<strong>数字签名</strong>，同时实现身份认证和不可否认。</p><p><code>数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密</code>。</p><p>但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。</p><p>签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。</p><img src="'+o+'" alt="image-20220919183627274" style="zoom:50%;"><p>刚才的这两个行为也有专用术语，叫做<strong>签名</strong>和<strong>验签</strong>。</p><p>只要你和网站互相交换公钥，就可以用签名和验签来确认消息的真实性，因为私钥</p><p>保密，黑客不能伪造签名，就能够保证通信双方的身份。</p><p>比如，你用自己的私钥签名一个消息我是小明。网站收到后用你的公钥验签，确认身份没问题，于是也用它的私钥签名消息我是某宝。你收到后再用它的公钥验一下，也没问题，这样你和网站就都知道对方不是假冒的，后面就可以用混合加密进行安全通信了。</p><h3 id="数字证书和-ca" tabindex="-1"><strong>数字证书和 CA</strong> <a class="header-anchor" href="#数字证书和-ca" aria-hidden="true">#</a></h3><p>到现在，综合使用对称加密、非对称加密和摘要算法，我们已经实现了安全的四大特性，是不是已经完美了呢?</p><p>不是的，这里还有一个<strong>公钥的信任</strong>问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是你或者某宝的公钥呢?</p><p>真是按下葫芦又起了瓢，安全还真是个麻烦事啊，一环套一环的。</p><p>我们可以用类似密钥交换的方法来解决公钥认证问题，用别的私钥来给公钥签名，显然，这又会陷入无穷递归。</p><p>但这次实在是没招了，要终结这个死循环，就必须引入外力，找一个公认的可信第三方，让它作为信任的起点，递归的终点，构建起公钥的信任链。</p><p>这个第三方就是我们常说的<strong>CA</strong>(Certificate Authority，证书认证机构)。它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</p><p>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还 要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥 关联的各种信息，形成<strong>数字证书</strong>(Certificate)。</p><p>知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。</p><p>DV 是最低的，只是域名级别的可信，背后是谁不知道。EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份(在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站)。</p><p>不过，CA 怎么证明自己呢?</p><p>这还是信任链的问题。小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是<strong>Root CA</strong>，就只能自己证明自己了，这个就叫<strong>自签名证书</strong>(Self-Signed Certificate)或者<strong>根证书</strong>(Root Certificate)。你必须相信，否则整个证书信任链就走不下去了。</p><img src="'+h+'" alt="image-20220919183924370" style="zoom:50%;"><p>有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链(Certificate Chain)一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。</p><h3 id="证书体系的弱点" tabindex="-1"><strong>证书体系的弱点</strong> <a class="header-anchor" href="#证书体系的弱点" aria-hidden="true">#</a></h3><p>证书体系(PKI，Public Key Infrastructure)虽然是目前整个网络世界的安全基础设施， 但绝对的安全是不存在的，它也有弱点，还是关键的<strong>信任</strong>二字。</p><p>如果 CA 失误或者被欺骗，签发了错误的证书，虽然证书是真的，可它代表的网站却是假的。</p><p>还有一种更危险的情况，CA 被黑客攻陷，或者 CA 有恶意，因为它(即根证书)是信任的源头，整个信任链里的所有证书也就都不可信了。</p><p>这两种事情并不是耸人听闻，都曾经实际出现过。所以，需要再给证书体系打上一些补丁。</p><p>针对第一种，开发出了 CRL(证书吊销列表，Certificate revocation list)和 OCSP(在线证书状态协议，Online Certificate Status Protocol)，及时废止有问题的证书。</p><p>对于第二种，因为涉及的证书太多，就只能操作系统或者浏览器从根上下狠手了，撤销对 CA 的信任，列入黑名单，这样它颁发的所有证书就都会被认为是不安全的。</p><h3 id="小结-2" tabindex="-1"><strong>小结</strong> <a class="header-anchor" href="#小结-2" aria-hidden="true">#</a></h3><ul><li>摘要算法用来实现完整性，能够为数据生成独一无二的指纹，常用的算法是 SHA- 2</li><li>数字签名是私钥对摘要的加密，可以由公钥解密后验证，实现身份认证和不可否认</li><li>公钥的分发需要使用数字证书，必须由 CA 的信任链来验证，否则就是不可信的</li><li>作为信任链的源头 CA 有时也会不可信，解决办法有 CRL、OCSP，还有终止信任</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-hidden="true">#</a></h2><p><a href="https://time.geekbang.org/column/intro/100029001" target="_blank" rel="noreferrer">透视HTTP协议(罗剑锋)</a></p>',132),c=[g];function S(T,u,C,L,A,_){return s(),r("div",null,c)}const H=t(d,[["render",S]]);export{P as __pageData,H as default};
