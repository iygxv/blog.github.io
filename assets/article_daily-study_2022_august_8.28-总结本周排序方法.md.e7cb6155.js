import{_ as e,c as a,o as l,N as o}from"./chunks/framework.5b6ea098.js";const f=JSON.parse('{"title":"8.28-总结本周排序方法","description":"","frontmatter":{},"headers":[],"relativePath":"article/daily-study/2022/august/8.28-总结本周排序方法.md"}'),t={name:"article/daily-study/2022/august/8.28-总结本周排序方法.md"},r=o('<h1 id="_8-28-总结本周排序方法" tabindex="-1">8.28-总结本周排序方法 <a class="header-anchor" href="#_8-28-总结本周排序方法" aria-label="Permalink to &quot;8.28-总结本周排序方法&quot;">​</a></h1><h2 id="本周所学" tabindex="-1">本周所学 <a class="header-anchor" href="#本周所学" aria-label="Permalink to &quot;本周所学&quot;">​</a></h2><p>本周学了5种排序算法, 分别是<code>冒泡排序</code>,<code>选择排序</code>,<code>快速排序</code>,<code>归并排序</code>,<code>插入排序</code>下面对各种算法进行总结</p><p><code>特别提醒: 主要实现降序</code></p><h2 id="冒泡排序" tabindex="-1">冒泡排序 <a class="header-anchor" href="#冒泡排序" aria-label="Permalink to &quot;冒泡排序&quot;">​</a></h2><p>冒泡排序的时间复杂度为O(n^2)</p><p><strong>算法的原理</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。<code>在这一点，最后的元素应该会是最大的数</code>(可优化的地方)</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li></ul><p><a href="https://codevity.top/article/every-insist/august/8.22-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html" target="_blank" rel="noreferrer">冒泡排序</a></p><h2 id="选择排序" tabindex="-1">选择排序 <a class="header-anchor" href="#选择排序" aria-label="Permalink to &quot;选择排序&quot;">​</a></h2><p>选择排序的时间复杂度为O(n^2)</p><p><strong>算法的原理</strong></p><ul><li>首先在未排序序列中找到最小元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><p><a href="https://codevity.top/article/every-insist/august/8.23-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html" target="_blank" rel="noreferrer">选择排序</a></p><h2 id="快速排序" tabindex="-1">快速排序 <a class="header-anchor" href="#快速排序" aria-label="Permalink to &quot;快速排序&quot;">​</a></h2><p>快速排序时间复杂度在<code>nlogn~ n^2 之间</code></p><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序</p><p><strong>算法的原理</strong></p><ul><li>先从给定的数组中取出一个基准数(<code>基准</code>)</li><li>划分过程，小于等于基准数的放在左边，大于基准数的放在右边(<code>分区</code>)</li><li>再对左右区间重复第2步操作，直到各区间只有一个数(<code>递归分区过程</code>)</li></ul><h2 id="归并排序" tabindex="-1">归并排序 <a class="header-anchor" href="#归并排序" aria-label="Permalink to &quot;归并排序&quot;">​</a></h2><p>快速排序时间复杂度在<code> nlog(n)</code></p><p><strong>算法的原理</strong></p><ul><li><p>第一步：申请空间，使其大小为两个已经<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F" target="_blank" rel="noreferrer">排序</a>序列之和，该空间用来存放合并后的序列</p></li><li><p>第二步：设定两个<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noreferrer">指针</a>，最初位置分别为两个已经排序序列的起始位置</p></li><li><p>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p></li><li><p>重复步骤3直到某一指针超出序列尾</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p></li></ul><p>归并排序的整体步骤比较难理解, <code>需要配合代码和动图来理解</code></p><p><a href="https://codevity.top/article/every-insist/august/8.25-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86" target="_blank" rel="noreferrer">归并排序</a></p><h2 id="插入排序" tabindex="-1">插入排序 <a class="header-anchor" href="#插入排序" aria-label="Permalink to &quot;插入排序&quot;">​</a></h2><p>插入排序时间复杂度在<code>n^2</code></p><p><strong>算法的原理</strong></p><ul><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>该元素（已排序的元素）大于当前元素，则将该元素移动到下一个位置</li><li>重复上一个步骤，直到找到已排序的元素小于或者等于当前元素的位置，将当前元素插入到该位置后，重复上面的步骤</li></ul><h3 id="特别提醒" tabindex="-1">特别提醒 <a class="header-anchor" href="#特别提醒" aria-label="Permalink to &quot;特别提醒&quot;">​</a></h3><ul><li>插入排序适合少量元素的排序的情况</li><li>相关: sort的原理在元素个数<code>少于10个的时候,使用的就是插入排序</code>, <code>大于10的时候, 使用的是插入 + 快速排序</code></li></ul><h2 id="二分查找" tabindex="-1">二分查找 <a class="header-anchor" href="#二分查找" aria-label="Permalink to &quot;二分查找&quot;">​</a></h2><p>在有序数组中, 我们可以使用<code>二分查找</code>来确定某个元素的位置</p><ul><li>在<code>二分查找</code>获取中间索引的时候, <code>(left + right) / 2</code>可能会溢出，<code> left + (right - left) /2</code>就不会溢出</li><li>特别注意: 使用二分查找的<code>前提</code>必须是一个<code>有序数组</code></li></ul>',34),i=[r];function d(c,n,s,h,p,u){return l(),a("div",null,i)}const g=e(t,[["render",d]]);export{f as __pageData,g as default};
